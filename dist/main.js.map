{"version":3,"file":"main.js","mappings":"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","sources":["webpack://fly-type/./src/scripts/movingObject.js","webpack://fly-type/./src/scripts/movingRectangle.js","webpack://fly-type/./src/scripts/movingCharacter.js","webpack://fly-type/./src/scripts/util.js","webpack://fly-type/./src/scripts/game.js","webpack://fly-type/./src/scripts/view.js","webpack://fly-type/./src/index.js"],"sourcesContent":["export default class MovingObject {\n\n    constructor(argsHash) {\n        this.xCoordinate = argsHash.xCoordinate; \n        this.yCoordinate = argsHash.yCoordinate;\n        this.xVelocity = argsHash.xVelocity; \n        this.yVelocity = argsHash.yVelocity; \n        this.color = argsHash.color;\n    }\n\n    move() {\n        // console.log(`before - x: ${this.xCoordinate} and y:${this.yCoordinate}`);\n        this.xCoordinate = this.xCoordinate + this.xVelocity;\n        this.yCoordinate = this.yCoordinate + this.yVelocity;\n        // console.log(`after - x: ${this.xCoordinate} and y:${this.yCoordinate}`);\n    }\n}","import MovingObject from \"./movingObject\";\n\nexport default class MovingRectangle extends MovingObject {\n    \n    constructor(argsHash) {\n        super(argsHash);\n        this.width = argsHash.width;\n        this.height = argsHash.height;\n        // debugger;\n    }\n\n    draw(canvasInterface) {\n        canvasInterface.fillStyle = this.color;\n        canvasInterface.fillRect(this.xCoordinate, this.yCoordinate, this.width, this.height);\n    }\n}\n\n// // Get a reference to the canvas element\n// const canvas = document.getElementById('my-canvas');\n\n// // Get the canvas context\n// const ctx = canvas.getContext('2d');\n\n// // Set the fill color and draw a filled rectangle\n// ctx.fillStyle = 'red';\n// ctx.fillRect(50, 50, 100, 100);\n\n// // Set the stroke color and draw a stroked rectangle\n// ctx.strokeStyle = 'blue';\n// ctx.strokeRect(200, 50, 100, 100);","import MovingRectangle from \"./movingRectangle\";\n\nexport default class MovingCharacter extends MovingRectangle {\n\n    static FONT = '20px Arial';\n\n    constructor(argsHash) {\n        super(argsHash);\n        this.character = argsHash.character;\n        this.color = (argsHash.color || \"black\");\n        this.canvasInterface = argsHash.canvasInterface;\n        this.typeable = argsHash.typeable;\n    }\n\n    draw(canvasInterface) {\n        // debugger;\n        canvasInterface.fillStyle = this.color;\n        canvasInterface.font = MovingCharacter.FONT;\n        canvasInterface.fillText(this.character, this.xCoordinate, this.yCoordinate);\n    }\n\n    get height(){\n        this.canvasInterface.font = MovingCharacter.FONT;\n        const fontMath = this.canvasInterface.measureText(this.character);\n        const h = fontMath.actualBoundingBoxAscent + fontMath.actualBoundingBoxDescent\n        \n        return h;\n    }\n\n    set height(value){\n        //setting height does nothing. Can only be set by changing the character\n    }\n}","import Game from \"./game\";\n\nexport function selectRand(array) {\n    if(!array.length) return null;\n\n    const randIndex = Math.floor(Math.random() * array.length);\n\n    return array[randIndex];\n}\n\nexport function genSentence() {\n    // debugger;\n\n    const adjective = selectRand(Game.ADJECTIVES);\n    const noun = selectRand(Game.NOUNS);\n    const verb = selectRand(Game.VERBS);\n    const adverb = selectRand(Game.ADVERBS);\n\n    const sentence = `${adjective} ${noun}s ${verb} ${adverb}`;\n    return sentence;\n}\n\nexport function setBanner(msg) {\n    const senDiv = document.getElementById(\"sentence\")\n    senDiv.innerHTML = msg;\n}","import MovingCharacter from \"./movingCharacter\";\nimport MovingRectangle from \"./movingRectangle\";\nimport { genSentence, selectRand, setBanner } from \"./util\";\n\nexport default class Game {\n   \n    // static DICTIONARY = [\"h\",\"j\",\"k\",\"l\"];\n    // static DICTIONARY = [\"h\"]; // limited test chars\n    \n    static ADJECTIVES = ['furry', 'happy', 'gloomy', 'friendly'];\n    static NOUNS = ['dog', 'cat', 'tree', 'mountain'];\n    static VERBS = ['ran', 'jumped', 'slept', 'ate'];\n    static ADVERBS = ['quickly', 'slowly', 'loudly', 'quietly'];\n\n    constructor(canvasInterface) {\n        this.canvasInterface = canvasInterface;\n        this.width = canvasInterface.canvas.width;\n        this.height = canvasInterface.canvas.height;\n        this.characters = [];\n        this.score = 0;\n        this.lives = 50;\n        this.gameOver = false;\n        this.resetSentence();\n        this.xCharOptions = [\n            this.width*0.20,\n            this.width*0.40,\n            this.width*0.60,\n            this.width*0.80\n        ];\n\n\n        // debugger;\n\n        //initialize the target bar that the letters will cross and give it starting positions\n        this.targetBar = new MovingRectangle({\n            xCoordinate: 0,\n            yCoordinate: 400,\n            xVelocity: 0, \n            yVelocity: 0, \n            color: \"lightgrey\",\n            width: this.width,\n            height: 30,\n            canvasInterface: this.canvasInterface\n        })\n    }\n\n    addChar() {\n            \n        // debugger;\n        if (this.noSpaceTarget.length > 0){\n\n            const vel = 1.5;\n            const newChar = new MovingCharacter({\n                xCoordinate: selectRand(this.xCharOptions),\n                yCoordinate: 0,\n                xVelocity: 0, \n                yVelocity: vel, \n                character: this.removeChar(),\n                canvasInterface: this.canvasInterface,\n                typeable: false\n            })\n            this.characters.push(newChar);\n        } else if (this.characters.length === 0) {\n            this.resetSentence();\n        }\n        // debugger;\n    }\n\n    removeChar() {\n        return this.noSpaceTarget.shift();\n    }\n\n    // sentenceCleared() {\n    //     return (this.noSpaceTarget.length === 0 || this.characters.length === 0)\n    // }\n\n    resetSentence() {\n        this.targetSentence = genSentence();\n        this.noSpaceTarget = Array.from(this.targetSentence.split(\" \").join(\"\"));\n        setBanner(this.targetSentence);\n    }\n\n    step() {\n        \n        for (let i = this.characters.length - 1; i >=0; i--) {\n            const char = this.characters[i];\n            char.move();\n\n            if (this.charOffCanvas(char)) {\n                // debugger;\n                // console.log(\"char deleted\");\n                this.characters.splice(i,1);\n            } else {\n                this.colorChar(char);\n            }\n        }\n        \n        //end game if score is <=0\n        if (this.lives <= 0) {\n            this.pause();\n            // this.characters = [];\n            // this.reset();\n            this.gameOver = true;\n            // console.log(\"game over\");\n            // debugger;\n        }\n        // console.log(this.characters.length, \"num of chars\");\n    }\n\n    charOffCanvas(char) {\n        if (char.yCoordinate > (this.height + char.height)) {\n            this.lives --;\n            return true\n        } else {\n            return false;\n        }\n    }\n\n    animate(){\n        this.drawBackdrop(\"beige\");\n        this.targetBar.draw(this.canvasInterface);\n        this.characters.forEach((char) =>{\n            char.draw(this.canvasInterface);\n        });\n        this.drawCounters();\n    }\n\n    drawCounters() {\n        \n        this.canvasInterface.fillStyle = \"black\";\n        this.canvasInterface.font = '14px Arial';\n        \n        //draw score\n        const scoreX =  0.01*this.width;\n        const scoreY =  0.99*this.height;\n\n        this.canvasInterface.fillText(`Score: ${this.score}`,scoreX,scoreY);\n\n        //draw lives\n        const livesX =  0.89*this.width;\n        const livesY =  0.99*this.height;\n        \n        this.canvasInterface.fillText(`Lives: ${this.lives}`,livesX,livesY);\n    }\n\n    start() {\n        this.gameOver = false;\n        this.gameInterval = setInterval(() => {\n            this.step();\n            \n            if (!this.gameOver) this.animate();\n        \n        }, 17);\n        \n        this.charInterval = setInterval(() => {\n            // console.log(\"char added\");\n            this.addChar();\n        }, 500);\n    }\n\n    pause() {\n        clearInterval(this.gameInterval);\n        clearInterval(this.charInterval);\n    }\n\n    colorChar(char) {\n        if (char.yCoordinate >= this.targetBar.yCoordinate && char.yCoordinate <= (this.targetBar.yCoordinate + this.targetBar.height + char.height)) {\n            char.typeable = true;\n            char.color = \"red\";\n        } else {\n            char.typeable = false;\n            char.color = \"black\";\n        }\n    }\n\n    \n    checkEntry(inputChar) {\n        debugger;\n        console.log(inputChar, \"input char\");\n        const matchingChars = this.characters.filter((char) => {\n            if(char.character === inputChar && char.typeable) {\n                this.score = this.score + 10;\n                this.lives = Math.min(this.lives + 1, 5);\n                return true;\n            }\n        })\n        if (matchingChars.length > 0) {\n            matchingChars.forEach((hitChar) => {\n                const delIdx = this.characters.indexOf(hitChar);\n                this.characters.splice(delIdx,1);\n            });\n        } else {\n            // console.log(\"miss!\");\n            return false;\n        }\n    }\n\n    drawBackdrop (color) {\n        this.canvasInterface.fillStyle = color;\n        this.canvasInterface.fillRect(0, 0, this.width, this.height);\n    }\n\n    replayScreen() {\n        // console.log(\"replay screen\")\n        this.drawBackdrop(\"grey\");\n        this.characters = [];\n        this.score = 0;\n        this.lives = 5;\n        this.charX = null;\n\n        // this.canvasInterface.fillStyle = \"black\";\n        // this.canvasInterface.font = '26px Arial';\n        \n        // //draw score\n        // const msgX =  0.20*this.width;\n        // const msgY =  0.50*this.height;\n\n        // this.canvasInterface.fillText(`Select return to play again!`,msgX,msgY);\n\n        setBanner(\"Game over :( select return to play again!\")\n    }\n\n    \n}\n        ","import Game from \"./game\";\n\nexport default class View {\n    \n    static INPUT = [\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n        'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n        'q', 'r', 's', 't', 'u', 'v', 'y', 'x',\n        'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F',\n        'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n        'Y', 'X', 'Y', 'Z'\n      ];\n\n    constructor(canvasInterface) {\n        this.canvasInterface = canvasInterface;\n        this.game = new Game(canvasInterface);\n        this.bindKeys();\n        this.gameRunning = false;\n        this.updateHTMLScore();\n        \n        // this.boundKeyHandler = this.handleKey.bind(this);\n        // document.cookie = '';\n        // debugger;\n    }\n\n    bindKeys() {\n\n        document.addEventListener('keydown', (event) => {\n            \n            this.handleKey(event);\n            // debugger;\n        });\n\n    }\n\n    handleKey(event) {\n        const key = event.key;\n        debugger;\n        switch(key) {\n            case ' ':\n                this.gameToggle();\n                break;\n            case 'ArrowRight':\n                this.game.step();\n                this.game.animate();\n                break;\n        }\n\n        if(View.INPUT.indexOf(key) >= 0) {\n            this.game.checkEntry(key);\n        } else {\n            console.log(key, \"non processed input\");\n        }\n    }\n\n    startGame() {\n        this.gameRunning = true;\n        this.game.start();\n\n        this.gameCheckInterval = setInterval(() => {\n            // console.log(\"game checked\");\n            this.checkGame();\n        }, 17);\n\n    }\n\n    //this checker checks whether the game is over and if so takes the necessary action\n    checkGame() {\n        if (this.game.gameOver) {\n            // this.game.gameOver = false;\n            // console.log(\"the game is over!!\")\n            clearInterval(this.gameCheckInterval);\n            this.gameRunning = false;\n\n            if (document.cookie === '' || this.game.score > this.cookieScore()){\n                document.cookie = `highScore=${this.game.score}`;\n                this.updateHTMLScore();\n            }\n\n            this.game.replayScreen();\n        }\n    }\n\n    cookieScore() {\n        let score = null;\n        const cookies = document.cookie;\n        const splitCookies = cookies.split(\";\");\n        for (let i = 0; i < splitCookies.length; i++) {\n            const pair = splitCookies[i];\n            const keyValue = pair.split(\"=\");\n\n            if (keyValue[0] === \"highScore\") {\n                score = parseInt(keyValue[1]);\n                break;\n            }\n        }\n\n        return score;\n    }\n\n    updateHTMLScore(){\n        const displayScore = this.cookieScore();\n        const scoreBoard = document.getElementById(\"scores\");\n        if (displayScore) {\n            scoreBoard.innerHTML = `High Score: ${displayScore}`;\n        } else {\n            scoreBoard.innerHTML = `No high score...yet`;\n        }\n    }\n\n    gameToggle(){\n        if (this.gameRunning) {\n            this.pauseGame();\n        } else {\n            this.startGame();\n        }\n    }\n\n    pauseGame(){\n        this.gameRunning = false;\n        this.game.pause()\n    }\n}\n\n","import Game from \"./scripts/game\";\nimport View from \"./scripts/view\";\n\n// const chance = require('chance').Chance();\n\n\n// const gameAssetDiv = document.getElementById(\"game-assets\");\n// const vertDivs = Array.from(document.getElementsByClassName(\"vertical-panel\"));\n\n// gameAssetDiv.style.height = \"550px\";\n// gameAssetDiv.style.width = \"1000px\";\n// debugger;\n// vertDivs.forEach(div => {\n//     div.style.height = '500px';\n// });\n\n// get the canvas element\nconst canvas = document.getElementById('game-canvas');\n\n//set the canvas dimensions according to game constants\ncanvas.width = 500;\ncanvas.height = 500;\n\n//get the canvas Interface\nconst canvasInterface = canvas.getContext('2d');\n\n//set the background for starters\n\n\nconst view = new View(canvasInterface);\nwindow.view = view;\nview.startGame();"],"names":["MovingObject","constructor","argsHash","this","xCoordinate","yCoordinate","xVelocity","yVelocity","color","move","MovingRectangle","super","width","height","draw","canvasInterface","fillStyle","fillRect","MovingCharacter","character","typeable","font","FONT","fillText","fontMath","measureText","actualBoundingBoxAscent","actualBoundingBoxDescent","value","selectRand","array","length","Math","floor","random","setBanner","msg","document","getElementById","innerHTML","Game","canvas","characters","score","lives","gameOver","resetSentence","xCharOptions","targetBar","addChar","noSpaceTarget","vel","newChar","removeChar","push","shift","targetSentence","ADJECTIVES","NOUNS","VERBS","ADVERBS","Array","from","split","join","step","i","char","charOffCanvas","splice","colorChar","pause","animate","drawBackdrop","forEach","drawCounters","scoreX","scoreY","livesX","livesY","start","gameInterval","setInterval","charInterval","clearInterval","checkEntry","inputChar","console","log","matchingChars","filter","min","hitChar","delIdx","indexOf","replayScreen","charX","_defineProperty","View","game","bindKeys","gameRunning","updateHTMLScore","addEventListener","event","handleKey","key","gameToggle","INPUT","startGame","gameCheckInterval","checkGame","cookie","cookieScore","splitCookies","keyValue","parseInt","displayScore","pauseGame","getContext","view","window"],"sourceRoot":""}