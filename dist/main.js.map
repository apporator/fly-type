{"version":3,"file":"main.js","mappings":"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","sources":["webpack://fly-type/./src/scripts/movingObject.js","webpack://fly-type/./src/scripts/movingRectangle.js","webpack://fly-type/./src/scripts/movingCharacter.js","webpack://fly-type/./src/scripts/util.js","webpack://fly-type/./src/scripts/spiral.js","webpack://fly-type/./src/scripts/game.js","webpack://fly-type/./src/scripts/view.js","webpack://fly-type/./src/index.js"],"sourcesContent":["export default class MovingObject {\n\n    constructor(argsHash) {\n        this.xCoordinate = argsHash.xCoordinate; \n        this.yCoordinate = argsHash.yCoordinate;\n        this.xVelocity = argsHash.xVelocity; \n        this.yVelocity = argsHash.yVelocity; \n        this.color = argsHash.color;\n        this.transparency = argsHash.transparency || 1;\n    }\n\n    move() {\n        // console.log(`before - x: ${this.xCoordinate} and y:${this.yCoordinate}`);\n        this.xCoordinate = this.xCoordinate + this.xVelocity;\n        this.yCoordinate = this.yCoordinate + this.yVelocity;\n        // console.log(`after - x: ${this.xCoordinate} and y:${this.yCoordinate}`);\n    }\n}","import MovingObject from \"./movingObject\";\n\nexport default class MovingRectangle extends MovingObject {\n    \n    constructor(argsHash) {\n        super(argsHash);\n        this.width = argsHash.width;\n        this.height = argsHash.height;\n        // debugger;\n    }\n\n    draw(canvasInterface) {\n        // canvasInterface.fillStyle = this.color;\n\n        const gradient = canvasInterface.createLinearGradient(this.xCoordinate, this.yCoordinate, this.xCoordinate, this.yCoordinate + this.height);\n        \n        gradient.addColorStop(0, \"#abdbe3\");\n        gradient.addColorStop(0.30, \"#76b5c5\");\n        gradient.addColorStop(0.5, \"#76b5c5\");\n        gradient.addColorStop(0.70, \"#76b5c5\");\n        gradient.addColorStop(1, \"#abdbe3\");\n        \n        // Set the fill style to the gradient\n        canvasInterface.fillStyle = gradient;\n        canvasInterface.fillRect(this.xCoordinate, this.yCoordinate, this.width, this.height);\n    }\n}\n\n// // Get a reference to the canvas element\n// const canvas = document.getElementById('my-canvas');\n\n// // Get the canvas context\n// const ctx = canvas.getContext('2d');\n\n// // Set the fill color and draw a filled rectangle\n// ctx.fillStyle = 'red';\n// ctx.fillRect(50, 50, 100, 100);\n\n// // Set the stroke color and draw a stroked rectangle\n// ctx.strokeStyle = 'blue';\n// ctx.strokeRect(200, 50, 100, 100);","import MovingRectangle from \"./movingRectangle\";\n\nexport default class MovingCharacter extends MovingRectangle {\n\n    // static FONT = '20px Georgia';\n    static FONT = '20px Alkatra';\n\n    constructor(argsHash) {\n        super(argsHash);\n        this.character = argsHash.character;\n        this.color = (argsHash.color || \"black\");\n        this.canvasInterface = argsHash.canvasInterface;\n        this.typeable = argsHash.typeable;\n        this.points = 0;\n    }\n\n    draw(canvasInterface) {\n        // debugger;\n        canvasInterface.fillStyle = this.color;\n        canvasInterface.font = MovingCharacter.FONT;\n        canvasInterface.fillText(this.character, this.xCoordinate, this.yCoordinate);\n    }\n\n    get height(){\n        this.canvasInterface.font = MovingCharacter.FONT;\n        const fontMath = this.canvasInterface.measureText(this.character);\n        const h = fontMath.actualBoundingBoxAscent + fontMath.actualBoundingBoxDescent\n        \n        return h;\n    }\n\n    set height(value){\n        //setting height does nothing. Can only be set by changing the character\n    }\n}","import Game from \"./game\";\n\nlet color = true;\n\nexport function selectRand(array) {\n    if(!array.length) return null;\n\n    const randIndex = Math.floor(Math.random() * array.length);\n\n    return array[randIndex];\n}\n\nexport function genSentence() {\n    // debugger;\n\n    const adjective = selectRand(Game.ADJECTIVES);\n    const noun = selectRand(Game.NOUNS);\n    const verb = selectRand(Game.VERBS);\n    const adverb = selectRand(Game.ADVERBS);\n\n    const sentence = `${adjective} ${noun}s ${verb} ${adverb}`;\n    return sentence;\n}\n\nexport function setBanner(msg) {\n    const senDiv = document.getElementById(\"sentence\")\n    senDiv.innerHTML = msg;\n}\n\nconst msgDiv = document.getElementById(\"message\")\n\nexport function setMsg(msg, color = \"\", background = \"\") {\n    msgDiv.style.backgroundColor = background;\n    msgDiv.style.color = color;\n    msgDiv.innerHTML = msg;\n}\n\nexport function getMsg() {\n    return msgDiv.innerHTML;\n}\n\nexport function calculateCirclePoints(centerX, centerY, radius, numPoints) {\n    const points = [];\n    for (let i = 0; i < numPoints; i++) {\n      const angle = i * 2 * Math.PI / numPoints;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      points.push({x: x, y: y});\n    }\n    return points;\n  }\n\n  const list = document.getElementById(\"lives-lost\");\n\n  export function appendMiss(msg) {\n    \n    let entry = document.createElement(\"li\");\n    entry.innerHTML = msg;\n    list.appendChild(entry);\n  }\n\n  export function clearMiss(){\n    list.innerHTML = \"\";\n  }","import MovingCharacter from \"./movingCharacter\";\nimport MovingObject from \"./movingObject\";\nimport { calculateCirclePoints } from \"./util\";\n\nexport default class Spiral extends MovingObject {\n\n    constructor(argsHash) {\n        super(argsHash);\n        this.canvasInterface = argsHash.canvasInterface;\n        this.radius = 30;\n        this.charCount = 10;\n        this.points = calculateCirclePoints(this.xCoordinate, this.yCoordinate, this.radius, this.charCount);\n        this.characters = [];\n        this.createChars();\n        this.counter = 0;\n        this.xDrop = this.points[0][\"x\"];\n        this.yDrop = this.points[0][\"y\"];\n    }\n\n    createChars() {\n        let alph = \"abcdefghijk\"\n\n        for (let i = 0; i < this.charCount; i++) {\n            const newChar = new MovingCharacter({\n                xCoordinate: this.points[i][\"x\"],\n                yCoordinate: this.points[i][\"y\"],\n                xVelocity: 0, \n                yVelocity: 0, \n                character: alph[i],\n                canvasInterface: this.canvasInterface,\n                typeable: false\n            })\n\n            this.characters.push(newChar);\n        }\n    }\n\n    move() {\n        ++this.counter;\n        \n        if(this.counter % 3 === 0) {\n            let firstX = this.characters[0].xCoordinate;\n            let firstY = this.characters[0].yCoordinate;\n\n            for (let index = 0; index < this.characters.length - 1; index++) {\n                const element = this.characters[index];\n                element.xCoordinate = this.characters[index+1].xCoordinate;\n                element.yCoordinate = this.characters[index+1].yCoordinate;\n            }\n\n            let lastChar = this.characters[this.characters.length-1];\n            lastChar.xCoordinate = firstX;\n            lastChar.yCoordinate = firstY;\n        }\n    }\n\n    draw (){\n        this.characters.forEach((char) => {\n            // debugger;\n            char.draw(this.canvasInterface);\n        })\n    }\n\n\n}","import MovingCharacter from \"./movingCharacter\";\nimport MovingRectangle from \"./movingRectangle\";\nimport Spiral from \"./spiral\";\nimport { genSentence, getMsg, selectRand, setBanner, setMsg,  appendMiss, clearMiss} from \"./util\";\n\nexport default class Game {\n   \n    // static DICTIONARY = [\"h\",\"j\",\"k\",\"l\"];\n    // static DICTIONARY = [\"h\"]; // limited test chars\n    \n    static ADJECTIVES = ['furry', 'happy', 'gloomy', 'friendly'];\n    static NOUNS = ['dog', 'cat', 'tree', 'mountain'];\n    static VERBS = ['ran', 'jumped', 'slept', 'ate'];\n    static ADVERBS = ['quickly', 'slowly', 'loudly', 'quietly'];\n\n    constructor(canvasInterface) {\n        this.canvasInterface = canvasInterface;\n        this.width = canvasInterface.canvas.width;\n        this.height = canvasInterface.canvas.height;\n        this.gameOver = false;\n        this.paused = true;\n\n        this.scoreOutput = document.getElementById(\"game-score\");\n        this.livesOutput = document.getElementById(\"game-lives\");\n\n        this.reset();\n\n        this.xCharOptions = [\n            this.width*0.20,\n            this.width*0.40,\n            this.width*0.60,\n            this.width*0.80\n        ];\n        \n        // this.img.style.width = '100%';\n        // this.img.style.height = '100%';\n\n\n        // debugger;\n\n        //initialize the target bar that the letters will cross and give it starting positions\n        this.targetBar = new MovingRectangle({\n            xCoordinate: 0,\n            yCoordinate: this.height*0.75,\n            xVelocity: 0, \n            yVelocity: 0, \n            color: \"lightgrey\",\n            width: this.width,\n            height: 50,\n            canvasInterface: this.canvasInterface,\n        })\n        // debugger;\n        // this.drawBackdrop();\n\n        this.img = new Image();\n        this.img.src = 'assets/fullLegalPad500.png';\n\n        this.img.onload = () => {\n            this.drawBackdrop();\n            this.targetBar.draw(this.canvasInterface);\n        }\n\n        // let spiralY = this.height*0.2;\n        this.wordSpirals = [];\n\n        this.xCharOptions.forEach((x) => {\n                const newSpiral = new Spiral({\n                xCoordinate: x,\n                yCoordinate: this.height*0.2,\n                xVelocity: 0, \n                yVelocity: 0, \n                // color: \"lightgrey\",\n                // width: this.width,\n                // height: 50,\n                canvasInterface: this.canvasInterface\n            })\n            this.wordSpirals.push(newSpiral);\n        });\n    }\n\n    printScore() {\n        this.scoreOutput.innerHTML = this.score;\n    }\n\n    printLives() {\n        this.livesOutput.innerHTML = this.lives;\n    }\n\n    addChar() {\n        const charToAdd = this.targetArray[0];\n        this.wordPause--;\n        if (this.wordPause > 0) {\n            --this.wordPause;\n        } else if (this.characters.length >= 1 && this.characters[this.characters.length-1].yCoordinate <= this.height*0.05) {\n            //do nothing if the most recently added character is still within the first 5% of the height of the board\n        }\n        else if(charToAdd === \" \") {\n            this.targetArray.shift();\n            this.wordPause = 3;\n            this.charVel = this.charVel*1.2;\n        }\n        else if (this.targetArray.length > 0 && this.wordPause <= 0){\n            const newChar = new MovingCharacter({\n                xCoordinate: selectRand(this.wordSpirals).xDrop,\n                yCoordinate: this.wordSpirals[0].yDrop,\n                xVelocity: 0, \n                yVelocity: this.charVel, \n                character: this.targetArray.shift(),\n                canvasInterface: this.canvasInterface,\n                typeable: false\n            })\n            this.characters.push(newChar);\n        } else if (this.characters.length === 0) {\n            this.resetSentence();\n        }\n    }\n\n    // removeChar() {\n    //     return this.noSpaceTarget.shift();\n    // }\n\n    // sentenceCleared() {\n    //     return (this.noSpaceTarget.length === 0 || this.characters.length === 0)\n    // }\n\n    resetSentence() {\n        this.targetSentence = genSentence();\n        this.targetArray = Array.from(this.targetSentence);\n        // this.noSpaceTarget = Array.from(this.targetSentence.split(\" \").join(\"\"));\n        setBanner(this.targetSentence);\n    }\n\n    step() {\n        \n        for (let i = this.characters.length - 1; i >=0; i--) {\n            const char = this.characters[i];\n            char.move();\n\n            if (this.charOffCanvas(char)) {\n                // debugger;\n                // console.log(\"char deleted\");\n                this.characters.splice(i,1);\n            } else {\n                this.colorChar(char);\n            }\n        }\n\n        this.wordSpirals.forEach((spiral) => {\n            spiral.move();\n        })\n        \n        //end game if score is <=0\n        if (!this.hasLives()) {\n            this.pause();\n            this.slowChars();\n            // this.drawCounters();\n            // this.characters = [];\n            // this.reset();\n            this.gameOver = true;\n            // debugger;\n            // console.log(\"game over\");\n            // debugger;\n        }\n        // console.log(this.characters.length, \"num of chars\");\n    }\n\n    slowChars() {\n        // console.log(\"chars slowed\");\n        this.characters.forEach((char) => {\n            char.yVelocity = 0.8;\n        })\n        this.wordPause = 15;\n        this.charVel = 2;\n    }\n\n    hasLives() {\n        return this.lives > 0;\n    }\n\n    charOffCanvas(char) {\n        if (char.yCoordinate > (this.height + char.height)) {\n            this.lives --;\n\n            let adder = \"\"\n\n            if (!this.hasLives()) {\n                adder = '. Enter to replay'\n            }\n\n            let msg = `Oh no, you missed ${char.character}${adder}`;\n\n            setMsg(msg, \"black\", \"grey\");\n            appendMiss(msg);\n            // this.pause();\n            this.slowChars();\n            this.animate(false);\n            return true\n        } else {\n            return false;\n        }\n    }\n\n    animate(withChars = true){\n        this.drawBackdrop();\n        this.targetBar.draw(this.canvasInterface);\n\n        this.characters.forEach((char) =>{\n            char.draw(this.canvasInterface);\n        });\n        \n        this.wordSpirals.forEach((spiral) => {\n            spiral.draw();\n        });\n        \n        this.drawCounters();\n    }\n\n    drawCounters() {\n        this.printLives();\n        this.printScore();\n    }\n\n    start() { \n        // debugger;\n        setMsg(\"\");\n        this.paused = false;\n        this.gameInterval = setInterval(() => {\n            // this.paused = false;\n            if (this.gameOver) {\n                this.reset();\n                this.gameOver = false;\n            }\n\n            this.step();\n            \n            if (!this.gameOver) this.animate();\n        \n        }, 17);\n        \n        this.charInterval = setInterval(() => {\n            // console.log(\"char added\");\n            this.addChar();\n        }, 500);\n    }\n\n    pause() {\n        clearInterval(this.gameInterval);\n        clearInterval(this.charInterval);\n        this.paused = true;\n        this.drawCounters();\n        // debugger;\n        // setMsg(\"Game paused. Space to resume.\")\n        this.addOverlay()\n    }\n\n    addOverlay(color = \"grey\", transparency = 0.5) {\n        this.canvasInterface.globalAlpha = transparency;\n        this.canvasInterface.fillStyle = color;\n        this.canvasInterface.fillRect(0,0,this.width,this.height);\n        this.canvasInterface.globalAlpha = 1;\n    }\n\n    checkEntry(inputChar) {\n\n        let validChar = null;\n\n        //1. for each character that matches the user's input and is in the hit zone, give the user points, increase their lives, and add the character to a separate array to be deleted\n        const matchingChars = this.characters.filter((char) => {\n            if(char.character === inputChar && char.typeable) {\n                // debugger;\n                if (char.points === 15) {\n                    setMsg(\"Right on target - Nice!\", \"red\", \"gold\");\n                } else {\n                    setMsg(\"Close....\", \"black\", \"grey\");\n                }\n\n                this.score = Math.floor(this.score + char.points*char.yVelocity);\n                // this.lives = Math.min(this.lives + 1, 3);\n                return true;\n            } else if (char.typeable) {\n                validChar = char.character;\n            }\n        })\n\n        // cycle through these matching characters and delete them from the game as they have been hit\n        if (matchingChars.length > 0) {\n            matchingChars.forEach((hitChar) => {\n                const delIdx = this.characters.indexOf(hitChar);\n                this.characters.splice(delIdx,1);\n            });\n        } else {\n            this.lives = this.lives - 1;\n\n            let adder = \"\";\n            \n            if(validChar) {\n                adder = ` instead of ${validChar}`;\n            }\n            \n            if (!this.hasLives()) {\n                adder = adder + \". Enter to replay!\"\n            }\n\n            let msg = `Argh. You entered ${inputChar}${adder}`;\n            setMsg(msg, \"yellow\", \"red\");\n            appendMiss(msg);\n            this.slowChars();\n            // this.pause();\n            this.animate(false);\n            return false;            \n        }\n    }\n\n    colorChar(char) {\n        //checks if it is within the topmost and bottommost bounds of the target bar\n        \n        //the top of the bar\n        const entry = this.targetBar.yCoordinate;\n        const exit = this.targetBar.yCoordinate + this.targetBar.height + char.height;\n\n        if (char.yCoordinate >= entry && char.yCoordinate <= exit) {\n\n            let diff = exit - entry;\n            let segment = (char.yCoordinate - entry) / diff\n\n            if (segment >= 0.2 && segment <= 0.8) {\n                char.color = \"yellow\";\n                char.points = 15;\n            } else {\n                char.color = \"red\";\n                char.points = 10;\n            }\n            char.typeable = true;      \n        } else {\n            char.typeable = false;\n            char.points = 0;\n            char.color = \"black\";\n        }\n    }\n\n    drawBackdrop () {\n        this.canvasInterface.clearRect(0, 0, this.width, this.height);\n        this.canvasInterface.globalAlpha = 0.4;\n        this.canvasInterface.drawImage(this.img,0,0)\n\n        this.canvasInterface.globalAlpha = 1;\n    }\n\n    // replayScreen() {\n    //     this.drawCounters();\n\n    //     const newMsg = `${getMsg()} Enter to replay.`\n    //     setMsg(newMsg, \"yellow\", \"red\");\n    //     // this.reset();\n    //     // this.animate();\n    //     // setMsg(\"Game over :( select return to play again!\")\n    // }\n\n    //called at initiation of each new game\n    reset() {\n        this.characters = [];\n        this.score = 0;\n        this.lives = 3;\n        this.charX = null;\n        this.resetSentence();\n        this.wordPause = 0;\n        this.charVel = 2;\n        this.printLives();\n        this.printScore();\n        clearMiss();\n    }\n}","import Game from \"./game\";\n\nexport default class View {\n    \n    static INPUT = [\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n        'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n        'q', 'r', 's', 't', 'u', 'v', 'y', 'x',\n        'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F',\n        'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n        'Y', 'X', 'Y', 'Z'\n      ];\n\n    constructor(canvasInterface) {\n        this.canvasInterface = canvasInterface;\n        this.game = new Game(canvasInterface);\n        this.bindKeys();\n        this.updateHTMLScore();\n\n    }\n\n    bindKeys() {\n\n        document.addEventListener('keydown', (event) => {\n            \n            this.handleKey(event);\n            // debugger;\n        });\n\n    }\n\n    handleKey(event) {\n        const key = event.key;\n        // debugger;\n\n        if (key === ' ' || key === 'Enter') {\n            // debugger;\n            // console.log(\"restarting\");\n            this.gameToggle();\n        } else if (key === 'ArrowRight') {\n            this.game.step();\n            this.game.animate();\n        } else if (View.INPUT.indexOf(key) >= 0 && !this.game.paused) {\n            this.game.checkEntry(key);  \n        } else if (key === \"1\")\n        {\n            this.game.lives = this.game.lives + 10;\n        }\n        else {\n            // console.log(key, `did not process your ${key}`);\n        }\n    }\n\n    //this checker checks whether the game is over and if so takes the necessary action\n    checkGame() {\n        if (this.game.gameOver) {\n            // this.game.gameOver = false;\n            // console.log(\"the game is over!!\")\n            clearInterval(this.gameCheckInterval);\n\n            if (document.cookie === '' || this.game.score > this.cookieScore()){\n                document.cookie = `highScore=${this.game.score}`;\n                this.updateHTMLScore();\n            }\n        }\n    }\n\n    cookieScore() {\n        let score = null;\n        const cookies = document.cookie;\n        const splitCookies = cookies.split(\";\");\n        for (let i = 0; i < splitCookies.length; i++) {\n            const pair = splitCookies[i];\n            const keyValue = pair.split(\"=\");\n\n            if (keyValue[0] === \"highScore\") {\n                score = parseInt(keyValue[1]);\n                break;\n            }\n        }\n\n        return score;\n    }\n\n    updateHTMLScore(){\n        const displayScore = this.cookieScore();\n        const scoreBoard = document.getElementById(\"scores\");\n        if (displayScore) {\n            scoreBoard.innerHTML = `High Score: ${displayScore}`;\n        } else {\n            scoreBoard.innerHTML = `No high score...yet`;\n        }\n    }\n\n    gameToggle(){\n        if(this.game.paused) {\n            this.game.start();\n            this.gameCheckInterval = setInterval(() => {\n                // console.log(\"game checked\");\n                this.checkGame();\n            }, 17);\n        } else {\n            clearInterval(this.gameCheckInterval);\n            this.game.pause()\n        }\n    }\n}\n\n","import Game from \"./scripts/game\";\nimport View from \"./scripts/view\";\n\n// const chance = require('chance').Chance();\n\n\n// const gameAssetDiv = document.getElementById(\"game-assets\");\n// const vertDivs = Array.from(document.getElementsByClassName(\"vertical-panel\"));\n\n// gameAssetDiv.style.height = \"550px\";\n// gameAssetDiv.style.width = \"1000px\";\n// debugger;\n// vertDivs.forEach(div => {\n//     div.style.height = '500px';\n// });\n\n// get the canvas element\nconst canvas = document.getElementById('game-canvas');\n\n//set the canvas dimensions according to game constants\ncanvas.width = 500;\ncanvas.height = 500;\n\n//get the canvas Interface\nconst canvasInterface = canvas.getContext('2d');\n\n//set the background for starters\n\n\nconst view = new View(canvasInterface);\nwindow.view = view;\n// view.startGame();"],"names":["MovingObject","constructor","argsHash","this","xCoordinate","yCoordinate","xVelocity","yVelocity","color","transparency","move","MovingRectangle","super","width","height","draw","canvasInterface","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","MovingCharacter","character","typeable","points","font","FONT","fillText","fontMath","measureText","actualBoundingBoxAscent","actualBoundingBoxDescent","value","selectRand","array","length","Math","floor","random","msgDiv","document","getElementById","setMsg","msg","arguments","undefined","background","style","backgroundColor","innerHTML","list","appendMiss","entry","createElement","appendChild","Spiral","radius","charCount","centerX","centerY","numPoints","i","angle","PI","x","cos","y","sin","push","calculateCirclePoints","characters","createChars","counter","xDrop","yDrop","newChar","firstX","firstY","index","element","lastChar","forEach","char","Game","canvas","gameOver","paused","scoreOutput","livesOutput","reset","xCharOptions","targetBar","img","Image","src","onload","drawBackdrop","wordSpirals","newSpiral","printScore","score","printLives","lives","addChar","charToAdd","targetArray","wordPause","shift","charVel","resetSentence","targetSentence","ADJECTIVES","NOUNS","VERBS","ADVERBS","Array","from","step","charOffCanvas","splice","colorChar","spiral","hasLives","pause","slowChars","adder","animate","drawCounters","start","gameInterval","setInterval","charInterval","clearInterval","addOverlay","globalAlpha","checkEntry","inputChar","validChar","matchingChars","filter","hitChar","delIdx","indexOf","exit","diff","segment","clearRect","drawImage","charX","_defineProperty","View","game","bindKeys","updateHTMLScore","addEventListener","event","handleKey","key","gameToggle","INPUT","checkGame","gameCheckInterval","cookie","cookieScore","splitCookies","split","keyValue","parseInt","displayScore","getContext","view","window"],"sourceRoot":""}